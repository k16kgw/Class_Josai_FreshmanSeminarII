# 数値計算1（2分法・ニュートン法）

出席パスワード：**483915**

到達目標
<!-- - **代数方程式**とは何かを理解する -->
- 解の公式のない方程式を **数値的に解く方法** を学ぶ
- **逐次近似法**（反復によって解に近づく手法）の考え方を習得する
- **2分法**および**ニュートン法**をプログラムで実装できるようになる

準備
1. anacondaを使用し，<span style="color:red">jupyter lab</span>を起動する．
2. `Document（書類）/Fresh`フォルダを開き，新しいノートブックを作成する．
3. ファイル名を`8_{学籍番号}_{氏名}.ipynb`に変更する．
    例：`8_SI25999_香川渓一郎.ipynb`

## 第7回の復習

- 整数の計算を行うアルゴリズムをプログラムに実装した．
- **エラトステネスの篩**，**最大公約数**など．
- アルゴリズムの考え方：
  1. 問題の性質を理解する
  2. 手順（アルゴリズム）を言葉で書く
  3. Pythonの構文で表現する（for, while, 条件分岐）

```{note}
<span style="color:red">**課題1**</span>

1. `prime_factorize()` を使い，整数 360 を素因数分解せよ．
2. 上の結果を`360 = 2^3 × 3^2 × 5`のように表示する関数を実装せよ．
```

解答例1-2
```python
def format_factorization(n):
    # 素因数のリストを得る
    factors = prime_factorize(n)

    # 出現回数を数える（辞書を使う）
    counts = {}
    for p in factors:
        if p in counts:
            counts[p] += 1
        else:
            counts[p] = 1

    # 2^3, 3^2, 5 のような文字列を作る
    parts = []
    for p in sorted(counts.keys()):
        e = counts[p]
        if e == 1:
            parts.append(f"{p}")
        else:
            parts.append(f"{p}^{e}")

    # " × " でつなぐ
    factor_str = " × ".join(parts)
    # 全体を「n = ...」の形にして出力する
    return f"{n} = {factor_str}"
```

```{note}
<span style="color:red">**課題2**</span>

1. 複数の数の最大公約数を求める関数`gcd_list(input_list)`を実装せよ．
2. 実装した`gcd_list`を簡単な例`[15, 10, 5]`に対して使用して，出力が`5`となることを確認せよ．
3. 実装した`gcd_list`を使用して`[210, 147, 90, 63]`の最大公約数を求めよ．
```

解答例2-1
```python
def gcd_list(input_list):
    # 最初の要素を初期値にする
    result = input_list[0]

    # 2番目以降の要素に対して，順に最大公約数を計算する
    for x in input_list[1:]:
        result = gcd(result, x)

    return result
```

---

## 代数方程式とその根（解）

```{tip}
2次方程式

$$
x^2 + x - 2 = 0
$$

の解は解の公式に当てはめれば求まる．

$$
ax^2 + bx + c = 0
$$

の解は

$$
x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}
$$

で与えられる．

幾何学的に理解をすれば，$y=\text{左辺}$のグラフと$y=0$のグラフとの交点が解となる．

![graph](/contents/figs/8/graph.png)
```

### 解の公式が存在しない方程式

一般に次の定理が知られている．

```{tip}
**代数学の基本定理**

係数が複素数の$n$次方程式（$n \geq 1$）は複素数の範囲で解を持つ．
```

しかし，解の公式があるかは別の問題である．
解の公式があるかどうかについて，次の定理が知られている．

```{tip}
**アーベル・ルフィニ定理** (Abel–Ruffini theorem)

$5$以上の任意の整数$n$に対して，一般の$n$次方程式を代数的に解く方法は存在しない．
```

例えば次のような方程式には**解の公式が存在しない**．

- $x^5 + x + 1 = 0$
- $x = \cos x$
- $\dfrac{x}{4} = \log x$

このような解の公式が存在しない方程式に対して，解の情報を得る一つの手段として数値的に近似解を求める方法がある．

そこで一般に方程式

$$
f(x) = 0
$$

の解（根）を求めることを考える．

例：
- $x^5 + x + 1 = 0$
- $x - \cos x = 0$
- $\dfrac{x}{4} - \log x = 0$

これらを繰り返し計算（**逐次近似法**）によって近似的に解く．
逐次近似法として**2分法**と**ニュートン法**があげられる．

---

## 2分法（bisection method）

ある2つの実数$a,b$に対して$f(a)$と$f(b)$の符号が異なるとき，その間に必ず根がある（中間値の定理）．

### 手順

1. 区間$[a, b]$の中点$m = (a + b) / 2$を求める．
2. $f(m)$の符号（$+$/$-$）を調べる．
3. $f(m)$と$f(a)$の符号が一致する場合，$m$を$a$に置き換える．または$f(m)$と$f(b)$の符号が一致する場合，$m$を$b$に置き換える．
4. 置き換えた$(a,b)$に対して1〜3を繰り返す．

### 実装例

ここでは例として

$$
f(x) = x^2 - 3 = 0
$$

の根（$\sqrt{3}$）を求める．

関数$f$を定義する．
```python
def f(x):
    return x**2 - 3
```

2分法を関数として実装する．

0. まず前提として区間$[a, b]$の端点$f(a)$と$f(b)$の符号が異なることを確認する．
    ```
    if f(a) * f(b) >= 0:
        print("2分法を使えません（符号が同じです）")
        return None
    ```
1. 区間$[a, b]$の中点$m = (a + b) / 2$を求める．
    ```
    m = (a+b)/2
    ```
2. $f(m)$の符号（$+$/$-$）を調べる．
3. $f(m)$と$f(a)$の符号が一致する場合，$m$を$a$に置き換える．または$f(m)$と$f(b)$の符号が一致する場合，$m$を$b$に置き換える．
   場合分けなのでif文として実装する．
    ```
    if f(a) * f(m) > 0:
        a = m
    else:
        b = m
    ```
4. 置き換えた$(a,b)$に対して1〜3を繰り返す．
   繰り返しの終了条件は，区間$[a,b]$の幅が一定値より小さくなったときとする．
    ```
    while b - a > eps:
    ```

これらをまとめると次のようになる．
```python
def bisection(a, b, eps=1e-6):
    if f(a) - f(b) >= 0:
        print("2分法を使えません（符号が同じです）")
        return None
    while b - a > eps:
        m = (a + b) / 2
        if f(a) * f(m) > 0:
            a = m
        else:
            b = m
    return (a + b) / 2
```

```{note}
**演習1**

上の2分法を使って，方程式  

$$
x^2 - 3 = 0
$$

の解を求めよ（区間$[1,2]$を与えると良い）．
```

```{note}
**演習2**

関数`bisection`を書き換え，終了条件が満たされるまでに繰り返された回数をprintするようにせよ．
このとき，$f(x) = x^2 - 3$，区間$[1,2]$としたときに繰り返された回数を答えよ．
```

```{note}
<span style="color:red">**課題1**</span>

次の方程式の解を1つ求めよ．区間の設定は適宜調整せよ．
適切な区間を探す過程で行った計算・コードは残しておくこと．

$$
\cos x - x = 0
$$

ただし$\cos$は`math`モジュールをインポートして使用する．
使用例：
```python
import math
x=1
print(math.cos(x))
```

<!-- ```python
import math
def g(x):
    return math.cos(x) - x
``` -->

---

## ニュートン法（Newton's method）

ニュートン法はニュートン・ラフソン法（Newton–Raphson method）とも呼ばれ，適切な初期値に対しては2分法より速く近似解を得ることのできる反復法である．

※ 適切な初期値でないと，近似解を得られずに発散することがあることに注意する．

### 手順

$i$ステップ目の$x$を$x_i$と表すこととする．

1. $n$ステップ目の$x$に対して，次に従って$x$を更新する．
    
    $$
    x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
    $$

2. 更新した$x$に対して，上を繰り返す．

```{tip}
**例**

$$
f(x) = x^2 - 3,\quad f'(x) = 2x
$$
```

### 実装例

関数$f$とその導関数を実装する．
```python
def f(x):
    return x**2 - 3

def df(x):
    return 2*x
```

1. $n$ステップ目の$x$に対して，次に従って$x$を更新する．
    
    $$
    x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
    $$

    ```
    x_new = x - f(x) / df(x)
    ```

2. 1を繰り返す．
   繰り返しの終了条件は，一定回数繰り返しを行った場合か，更新した$x$と更新前の$x$との差が一定値より小さくなったときとする．
    ```
    for i in range(max_iter):
    ```
    ```
    if abs(x_new - x) < eps:
        return x_new
    ```

これらをまとめると次のようになる．
```python
def newton(x0, eps=1e-6, max_iter=100):
    x = x0
    for i in range(max_iter):
        x_new = x - f(x) / df(x)
        if abs(x_new - x) < eps:
            return x_new
        x = x_new
    return x
```

```{note}
**演習3**

上のニュートン法を使って，方程式  

$$
x^2 - 3 = 0
$$

の解を求めよ（初期値は$2$とする）．
```

```{note}
**演習4**

関数`newton`を書き換え，終了条件が満たされるまでに繰り返された回数をprintするようにせよ．
ここで，$f(x) = x^2 - 3$，初期値$2$としたときに繰り返された回数を答えよ．
```

```{note}
<span style="color:red">**課題2**</span>

次の方程式の解を1つ求めよ．初期値の設定は適宜調整せよ．
適切な初期値を探す過程で行った計算・コードは残しておくこと．

$$
\cos x - x = 0
$$
```

```{note}
<span style="color:red">**課題3**</span>

次の方程式について考える．

$$
f(x) = \dfrac{2-x}{x^2}
$$

1. 2分法やニュートン法を用いて方程式の解を1つ求めよ．（どちらを使用しても良い）

2. ニュートン法を用いて方程式の解を求めるにあたり，近似解が得られずに発散する初期値を1つ見つけよ．

3. 近似解が得られずに発散する状況の特徴を述べよ．（正答でなくとも話の筋が通っていれば加点する）
```

---

## 2分法とニュートン法の比較

| 方法         | 収束速度        | 必要条件           | 長所      | 短所        |
| ---------- | ----------- | -------------- | ------- | --------- |
| **2分法**    | 遅い（線形収束）    | 区間[a,b]で符号が異なる | 必ず収束，安定 | 収束が遅い     |
| **ニュートン法** | 非常に速い（二次収束） | 導関数が必要，初期値が重要  | 収束が速い   | 初期値が悪いと発散 |

---

## まとめ

- 解の公式がない方程式は，数値計算を使って解く
- 逐次近似法：反復計算により解に近づく手法
- **2分法**：必ず収束するが遅い
- **ニュートン法**：速いが初期値と導関数が必要

```{note}
演習1〜4及び課題1〜3を実施したipynbファイルをWebClassの「第8回課題」より提出してください．

提出期限は12月8日10:59です．
```

