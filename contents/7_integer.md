# 整数を扱う計算

出席パスワード：**915284**

到達目標
- **エラトステネスの篩**や**素因数分解**を例に，アルゴリズムをプログラムに実装できるようになる．

準備
1. anacondaを使用し，<span style="color:red">jupyter lab</span>を起動する．
2. `Document（書類）/Fresh`フォルダを開き，新しいノートブックを作成する．
3. ファイル名を`7_{学籍番号}_{氏名}.ipynb`に変更する．
   　例：`7_SI25999_香川渓一郎.ipynb`

## 第6回の復習

- list, dict, strごとの**メソッド**
- **ファイル操作**

    - 書き込み

    ```python
    with open("message.txt", "w") as f:
        f.write("1行目\n")
        f.write("2行目\n")
    ```

    - 読み取り

    ```python
    with open("message.txt", "r") as f:
        text = f.read()
        print(text)
    ```

- **pandas**を用いたCSVファイルの読み書き
- 条件抽出（`df[df["数学"] >= 80]`）

---

## 約数と素数

### 約数

約数：整数 $n$ に対し，$n$ を割り切る整数

例：
- 12 の約数 → 1, 2, 3, 4, 6, 12
- 15 の約数 → 1, 3, 5, 15

### 素数

素数：$1$より大きく，**約数が$1$と自分自身だけ**の数

例：2, 3, 5, 7, 11, 13, 17, …

```python
def is_prime(n):
    if n <= 1:
        return False
    for k in range(2, int(n**0.5)+1):
        if n % k == 0:
            return False
    return True
```

```{note}
**演習1**

1. 上で定義した素数判定の関数`is_prime`を使い，1～100までに存在する全ての素数を表示せよ．
2. 整数$n$に対し，$n$の全ての約数をリストで返す関数`divisors`を実装せよ．
```

解答例1-1
```python
# 1～100 の素数をすべて表示
for n in range(1, 101):
    if is_prime(n):
        print(n)
```

解答例1-2
```python
def divisors(n):
    divs = []
    for k in range(1, n+1):
        if n % k == 0:
            divs.append(k)
    return divs
```

---

## エラトステネスの篩（ふるい）(Sieve of Eratosthenes)

素数を大量に求める高速なアルゴリズム

次のアルゴリズムで自然数$N$までの素数を求める．
1. $2$〜$N$の整数を並べる．
2. 最小の数を素数として確定する．
3. 2で確定した素数の倍数を全て消す．
4. 次の残った数に対して2,3を繰り返す．

```{tip}
**例**

$N=15$までの素数をエラトステネスの篩に従って求める．

```text
2,3,4,5,6,7,8,9,10,11,12,13,14,15
→ 2は素数

~,3,~,5,~,7,~,9,~~,11,~~,13,~~,15
→ 3は素数

~,~,~,5,~,7,~,~,~~,11,~~,13,~~,~~
→ 5は素数

~,~,~,~,~,7,~,~,~~,11,~~,13,~~,~~
→ 7は素数

~,~,~,~,~,~,~,~,~~,11,~~,13,~~,~~
→ 11は素数

~,~,~,~,~,~,~,~,~~,~~,~~,13,~~,~~
→ 13は素数

~,~,~,~,~,~,~,~,~~,~~,~~,~~,~~,~~
```

### 実装例

```python
def sieve(n):
    numbers = list(range(2,n+1))
    primes = []
    while len(numbers) > 0:
        p = numbers[0]
        primes.append(p)
        for i in range(1, n//p + 1):
            try:
                numbers.remove(p * k)
            except ValueError:
                pass   # すでに消されている場合は無視する
    return primes
```
<!-- 
```{tip}
**余談**

Cloudflareの大規模障害は，エラー処理が甘かったことが原因．
```
 -->

```{tip}
**余談**

上のコードはremoveを何度も使用することにより計算時間が長くなり効率的でない．
removeで指定した数字を探すためにリスト内の要素を全て調べ上げ，さらにリストの長さを短くするとコンピュータ上のデータの位置の取り直しが行われる．

`numbers`のリストの何番目の要素が素数かを判定するためのリスト`is_prime`を使用することで，リストの長さを変えずにアルゴリズムを実行でき，計算時間が長くなるのを防げる．

```python
def sieve(n):
    is_prime = [True] * (n+1)
    is_prime[0] = is_prime[1] = False # 
    for k in range(2, int(n**0.5)+1):
        # √nまで調べれば十分
        if is_prime[k]:
            for x in range(k*k, n+1, k):
                # 2乗より大きい範囲で倍数を消せば十分
                is_prime[x] = False
    return [i for i in range(2, n+1) if is_prime[i]]
    # iを2からnまで繰り返すが（for i in range(2, n+1)），iが素数のとき（is_prime[i]がTrue）のときだけiをリストに入れる．
```

```{note}
**演習2**

1. `sieve(100)` を実行し，100以下の素数を表示せよ．
2. 100以下の素数の個数を数え，次の形式で表示せよ：

```text
100以下の素数の個数は X 個です。
```

1の出力例
```text
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
```

2の解答例
```python
primes = sieve(100)
print(f"100以下の素数の個数は{len(primes)}個です。")
```

---

## 素因数分解

**素因数分解**：整数$n$を素数の積に分解する．

例：
- 12 → 2 × 2 × 3
- 60 → 2 × 2 × 3 × 5

### 実装例

```python
def prime_factorize(n):
    factors = []
    k = 2

    while k*k <= n:
        while n % k == 0:
            factors.append(k)
            n //= k
        k += 1

    if n > 1:
        factors.append(n)

    return factors
```

```{note}
<span style="color:red">**課題1**</span>

1. `prime_factorize()` を使い，整数 360 を素因数分解せよ．
2. 上の結果を`360 = 2^3 × 3^2 × 5`のように表示する関数を実装せよ．
```

<!-- 
出力例：
`[2, 2, 2, 3, 3, 5]`
 -->

---

## 最大公約数（greatest common denominator, GCD）

### ユークリッドの互除法（Euclidean algorithm）

最大公約数は次の定理に基づくアルゴリズムで求められる．

```{tip}
**定理**

2つの自然数$a,b$（$a>b$）に対し，$a$を$b$で割った余りを$r$とする．
このとき，$a$と$b$の最大公約数は$b$と$r$の最大公約数に等しい．
```

$a>b>r$であるから，$(a,b)$から$(b,r)$を求めて$(b,r)$を新たな$(a,b)$とし，この手続きを繰り返し実施すれば，$r=0$すなわち$b=0$となって手続きが終了する．
手続きが終了したタイミングでの$a$が最大公約数となる．

例：
$42$と$30$の最大公約数を求める．

$(42,30) \to (30,12) \to (12,6) \to (6,0)$

であるから，$42$と$30$の最大公約数は$6$である．

### 実装例

$(a,b)$から$(b,r=a\%b)$を得るので

```python
r = a % b
a, b = b, r
```

とすれば良い．
この手続きを$b$が$0$になるまで続ければ良いので

```python
while b != 0:
    r = a % b
    a, b = b, r
```

としてwhile文のブロックに入れれば良い．
whileループが終了するときの$a$が最大公約数になるから，関数の出力はwhileループの次に`return a`とする．
従って，関数は次のように実装すれば良い．

```python
def gcd(a, b):
    while b != 0:
        r = a % b
        a, b = b, r
    return a
```

```{note}
**演習3**

1. $a$が$b$の整数倍になっているような簡単な例となる$(a,b)$を考え，それについて`gcd(a, b)`を計算して正しく動作していることを確認せよ．
（$a = n \times b$のとき，$a$と$b$の最大公約数は$b$となる．）
```

```{note}
<span style="color:red">**課題2**</span>

1. 複数の数の最大公約数を求める関数`gcd_list(input_list)`を実装せよ．
2. 実装した`gcd_list`を簡単な例`[15, 10, 5]`に対して使用して，出力が`5`となることを確認せよ．
3. 実装した`gcd_list`を使用して`[210, 147, 90, 63]`の最大公約数を求めよ．
```

<!-- # 5. チャレンジ課題（余力のある人へ）

### **チャレンジ1：素因数分解を使って GCD を求める**

両方を素因数分解し，共通部分の積を求めよ．

### **チャレンジ2：LCM（最小公倍数）を求める関数**

最大公約数を使えば

$$
\text{LCM}(a, b) = \frac{a b}{\gcd(a, b)}
$$

### **チャレンジ3：1～N の間で最も素因数が多い数を調べる**

例：N=1000 -->

---

## まとめ

- 素数を求めるプログラム（**エラトステネスの篩**）を実装した．
- **素因数分解**を行うプログラムを実装した．
- **ユークリッドの互除法**によって最大公約数を求めるプログラムを実装した．

```{note}
演習1,2,3・課題1,2を実施したipynbファイルをWebClassの「第7回課題」より提出してください．

提出期限は12月1日10:59です．
```
